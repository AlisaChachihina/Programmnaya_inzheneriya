Отчет по Теме №10 выполнила:
- Чащихина Алиса Андреевна
- ПИЭ-21-2

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |

Работу проверили:
- к.э.н., доцент Панов М.А.

 ## Лабораторная работа №1
### Наверняка вы думаете, что декораторы – это какая-то бесполезная вещь, которая вам никогда не пригодится, но тут вдруг на паре по математике преподаватель просит всех посчитать число Фибоначчи для 100. Кто-то будет считать вручную (так точно не нужно), кто-то посчитает на калькуляторе, а кто-то подумает, что он самый крутой и напишет рекурсивную программу на Python и немного огорчится, потому что данная программа будет достаточно долго считаться, если ее просто так запускать. Но именно тут к вам на помощь приходят декораторы, например @lru_cache (он предназначен для решения задач динамическим программированием, если простыми словами, то этот декоратор запоминает промежуточные результаты и при рекурсивном вызове функции программа не будет считать одни и те же значения, а просто “возьмёт их из этого декоратора”). Вам нужно написать программу, которая будет считать числа Фибоначчи для 100 и запустить ее без этого декоратора и с ним, посмотреть на разницу во времени решения поставленной задачи.

```python
from functools import lru_cache
@lru_cache(None)
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n-1) + fibonacci(n-2)
if __name__ == '__main__':
    print(fibonacci(100))
```

### Результат.
![Снимок экрана 2023-12-04 131554](https://github.com/AlisaChachihina/Programmnaya_inzheneriya/assets/55950179/34e01a08-0a60-4a36-b0e1-26cd0415fbb5)

![Снимок экрана 2023-12-04 131648](https://github.com/AlisaChachihina/Programmnaya_inzheneriya/assets/55950179/39ba9bde-2545-4937-a3d9-d4cb7bc53c3f)


 ## Лабораторная работа №2
### Илья пишет свой сайт и ему необходимо сделать минимальную проверку ввода данных пользователя при регистрации. Для этого он реализовал функцию, которая выводит данные пользователя на экран и решил, что будет проверять правильность введённых данных при помощи декоратора, но в этом ему потребовалась ваша помощь. Напишите декоратор для функции, который будет принимать все параметры вызываемой функции (имя, возраст) и проверять чтобы возраст был больше 0 и меньше 130. Причем заметьте, что неважно сколько пользователь введет данных на сайт к Илье, будут обрабатываться только первые 2 аргумента.

```python
def check(input_func):
    def output_func(*args):
        name, age = args[0], args[1]
        if age <0 or age > 130:
            age = 'Недопустимый возраст'
        input_func(name, age)
    return output_func
@check
def personal_info(name, age):
    print(f"Name: {name}  Age: {age}")
if __name__ == '__main__':
    personal_info('', 38)
    personal_info('', -5)
    personal_info('', 138, 15, 48, 2)
```

### Результат.
![Снимок экрана 2023-12-04 133906](https://github.com/AlisaChachihina/Programmnaya_inzheneriya/assets/55950179/4553d586-3dc9-4e71-920a-4c2133b12d94)

 ## Лабораторная работа №3
### Вам понравилась идея Ильи с сайтом, и вы решили дальше работать вместе с ним. Но вот в вашем проекте появилась проблема, кто-то пытается сломать вашу функцию с получением данных для сайта. Эта функция работает только с данными integer, а какой-то недохакер пытается все сломать и вместо нужного типа данных отправляет string. Воспользуйтесь исключениями, чтобы неподходящий тип данных не ломал ваш сайт.


```python
def data(*args):
    try:
        for i in range(len(*args)):
            try:
                result = (args[0][i] * 15) // 10
                print(result)
            except Exception as ex:
                print(ex)
    except Exception as ex:
        print(ex)
    finally:
        print('Вся информация обработана')
if __name__ == '__main__':
    data([1, 15, 'Hello', 'i', 'try', 'to', 'crash', 'your', 'site', 38, 45])
```

### Результат.
![Снимок экрана 2023-12-04 134533](https://github.com/AlisaChachihina/Programmnaya_inzheneriya/assets/55950179/c0c81e15-7ac5-4bd6-bd81-a3ace6d675dd)



 ## Лабораторная работа №4
### Продолжая работу над сайтом, вы решили написать собственное исключение, которое будет вызываться в случае, если в функцию проверки имени при регистрации передана строка длиннее десяти символов, а если имя имеет допустимую длину, то в консоль выводиться “Успешная регистрация”

```python
class NegativeValueException(Exception):
    pass
def check_name(name):
    if len(name) > 10:
        raise NegativeValueException('Длина более 10 символов')
    else:
        print('Успешная регистрация')
if __name__ == '__main__':
    name = '12345678910'
    check_name(name)
```

### Результат.
![Снимок экрана 2023-12-04 135030](https://github.com/AlisaChachihina/Programmnaya_inzheneriya/assets/55950179/5144be73-41a3-4c3e-a5d2-fba03f325e2f)

 ## Лабораторная работа №5
### После запуска сайта вы поняли, что вам необходимо добавить логгер, для отслеживания его работы. Готовыми вариантами вы не захотели пользоваться, и поэтому решили создать очень простую пародию. Для этого создали две функции:		init		() (вызывается при создании класса декоратора в программе) и	call	() (вызывается при вызове декоратора). Создайте необходимый вам декоратор. Выведите все логи в консоль.

```python
class SiteChecker:
    def __init__(self, func):
        print('> Класс SiteChecker метод __init__ успешный запуск')
        self.func = func
    def __call__(self):
        print('> Проверка перед запуском', self.func.__name__)
        self.func()
        print('> Проверка безопасного выключения')
@SiteChecker
def site():
    print('Усердная работа сайта')
if __name__ == '__main__':
    print('>> Сайт запущен')
    site()
    print('>> Сайт выключен')
```

### Результат.
![Снимок экрана 2023-12-04 140400](https://github.com/AlisaChachihina/Programmnaya_inzheneriya/assets/55950179/bdf66d18-17e7-4951-8464-c72d177390d5)

 ## Самостоятельная работа №1
### Вовочка решил заняться спортивным программированием на python, но для этого он должен знать за какое время выполняется его программа. Он решил, что для этого ему идеально подойдет декоратор для функции, который будет выяснять за какое время выполняется та или иная функция. Помогите Вовочке в его начинаниях и напишите такой декоратор.

```python
import time #импортируем библиотеку time


def count_time(func): # создаем функцию высшего порядка
    def wrapper(): #определяем функцию
        start = time.time() #получаем время до запуска функции
        func() #выполняем функцию
        end = time.time() # получаем время после выполнения функции
        print() #переносим вывод на следующую строчку
        print(f"{(end - start) * 1000} ms") #получаем время выполнения функции и переводим в миллисекунды
    return wrapper #возвращаем значение функции


@count_time #добавляем декоратор к функции
def fibonacci(): #создаем функцию считающую числа фибоначи
    fib1 = fib2 = 1 #создаем первые числа фибоначи
    for i in range(2, 200): #считаем следующие числа фибоначи до 200
        fib1, fib2 = fib2, fib1 + fib2 #высчитываем следующее число фибоначи
        print(fib2, end=' ') #выводим числа фибоначи в одну строчку


fibonacci() #выполняем функцию
```

### Результат.
![Снимок экрана 2023-12-04 231602](https://github.com/AlisaChachihina/Programmnaya_inzheneriya/assets/55950179/0ca53bb2-0bb2-4478-8d94-6d0aaf8d1814)

## Выводы
Создаем декоратор, который считает время выполнения переданной функции. Написали функцию, считающую 200 чисел Фибоначчи. И добавили к ней созданный декоратор. Посчитали время выполнения функции

 ## Самостоятельная работа №2
### Посмотрев на Вовочку, вы также загорелись идеей спортивного программирования, начав тренировки вы узнали, что для решения некоторых задач необходимо считывать данные из файлов. Но через некоторое время вы столкнулись с проблемой что файлы бывают пустыми, и вы не получаете вводные данные для решения задачи. После этого вы решили не просто считывать данные из файла, а всю конструкцию оборачивать в исключения, чтобы избежать такой проблемы. Создайте пустой файл и файл, в котором есть какая-то информация. Напишите код программы. Если файл пустой, то, нужно вызвать исключение (“бросить исключение”) и вывести в консоль “файл пустой”, а если он не пустой, то вывести информацию из файла.

```python
f_empty = open('2_empty.txt', 'r', encoding="utf-8") #открываем пустой файл на чтение
f_not_empty = open('2_not_empty.txt', 'r', encoding="utf-8") #открываем непустой файл на чтение


def read_file(file): #создаем функцию чтения из файла
    lines = file.readlines() #считываем все строки из файла
    if len(lines) == 0: #если количество строк равно 0:
        raise Exception("файл пустой") #генерируем исключение, что файл пустой
    else: #если количество строк больше 0
        for line in lines: # идем по каждой считанной строке
            print(line) #выводим каждую строчку на новой строке


read_file(f_not_empty) #выполняем функцию с непустым файлом
read_file(f_empty) #выполняем функцию с пустым файлом
```

### Результат.
![Снимок экрана 2023-12-04 231634](https://github.com/AlisaChachihina/Programmnaya_inzheneriya/assets/55950179/4838d522-8a7c-498a-9e20-f2dc9b7b488d)

## Выводы
Открыли на чтение один пустой и один непустой файл. Написали функцию, которая принимает файл и пытается считать данные из файла. если файл пустой, то генерируется ошибка с сообщением, что файл пустой. Если файл не пустой, то выводятся данные из файла. Применили эту функцию к двум открытым файлам. 

 ## Самостоятельная работа №3
### Напишите функцию, которая будет складывать 2 и введенное пользователем число, но если пользователь введет строку или другой неподходящий тип данных, то в консоль выведется ошибка “Неподходящий тип данных. Ожидалось число.”. Реализовать функционал программы необходимо через try/except и подобрать правильный тип исключения. Создавать собственное исключение нельзя. Проведите несколько тестов, в которых исключение вызывается и нет. 

```python
def try_sum(): #создаем функцию суммы
    user_input = input() #считываем данные с консоли
    try: #открываем блок try
        user_int = int(user_input) # переводим строку в int
        return user_int + 2 # возвращаем значение функции плюс 2
    except ValueError: #ловим ошибку, если не получилось перевести строку в int
        raise ValueError("Неподходящий тип данных. Ожидалось число.") #генерируем ошибку с сообщением


print(try_sum()) #вызываем функцию с числом
print(try_sum()) #вызываем функцию с строкой

```

### Результат.
![Снимок экрана 2023-12-04 231722](https://github.com/AlisaChachihina/Programmnaya_inzheneriya/assets/55950179/afd208b4-a5b9-454b-86c7-4c948168c78a)

## Выводы
Создали функцию, которая пытается перевести данные, полученные с консоли, в число и вернуть сумму этого числа и двойки. Если данные не получается перевести в число, то ловится ошибка с сообщением "Неподходящий тип данных. Ожидалось число.".

 ## Самостоятельная работа №4
### Создайте собственный декоратор, который будет использоваться для двух любых вами придуманных функций. Декораторы, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс декоратора, две как-то связанными с ним функциями, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.

```python
class CopyrightDecorator: #создаем класс декоратора
    def __init__(self, func): #определяем конструктор с параметром функции
        self.func = func #определяем аттрибут func со значением параметра

    def __call__(self, *args, **kwargs): #определяем функцию вызова
        print(f"Function {self.func.__name__} made by Alisa") #выводим сообщение копирайта
        result = self.func(*args, **kwargs) #выполняем функцию
        return result #возвращаем значение функции


@CopyrightDecorator #добавляем декоратор к функции
def sum_elements(a1, a2): #создаем функцию сложения двух элементов
    return a1 + a2 #возвращаем сумму двух эелементов


@CopyrightDecorator #добавляем декоратор к функции
def print_message(message): #создаем функцию вывода сообщения
    print(message) # выводим сообщение


print(sum_elements(1, 2)) # выводим результат функции суммы эелементов
print_message("Message") #выводим сообщение
```

### Результат.
![Снимок экрана 2023-12-04 231742](https://github.com/AlisaChachihina/Programmnaya_inzheneriya/assets/55950179/fd80aeff-3623-42a4-a157-804649555574)

## Выводы
Создали собственный класс декоратора, который принимает функцию и перед её выполнением выводит сообщение копирайта в консоль. Создали две функции и добавили к ним созданный декоратор.

 ## Самостоятельная работа №5
### Создайте собственное исключение, которое будет использоваться в двух любых фрагментах кода. Исключения, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс исключения, код к котором в двух местах используется это исключение, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.

```python
class MoreTenOrLessFiveSimbolsException(Exception): #создаем класс ошибки и наследуемся от класса Exception

    @staticmethod #добавляем декоратор статичной функции
    def message_more_ten(simbols): # создаем функцию, возвращающую сообщение ошибки, что символов больше 10
        return f"{simbols} simbols is more that 10 simbols" #возвращаем сообщение

    @staticmethod #добавляем декоратор статичной функции
    def message_less_five(simbols): ## создаем функцию, возвращающую сообщение ошибки, что символов меньше 5
        return f"{simbols} simbols is less that 5 simbols" #возвращаем сообщение


a = input() #считываем строку с консоли
try: #открываем блок try
    if len(a) > 10: #проверяем, что количество символов больше 10
        raise MoreTenOrLessFiveSimbolsException(MoreTenOrLessFiveSimbolsException.message_more_ten(len(a))) #генерируем ошибку с сообщением, что символов больше 10
    if len(a) < 5: #проверяем, что количество символов меньше 5
        raise MoreTenOrLessFiveSimbolsException(MoreTenOrLessFiveSimbolsException.message_less_five(len(a))) #генерируем ошибку с сообщением, что символов меньше 5
finally: #открываем блок finally
    print(len(a)) #выводим длину строки
```

### Результат.
![Снимок экрана 2023-12-04 231846](https://github.com/AlisaChachihina/Programmnaya_inzheneriya/assets/55950179/cbf53baf-cb0f-4c94-9fe8-cd56ddfe41dd)

![Снимок экрана 2023-12-04 231911](https://github.com/AlisaChachihina/Programmnaya_inzheneriya/assets/55950179/d70c172b-0fce-41b3-b97f-1f9fcba73576)

![Снимок экрана 2023-12-04 231925](https://github.com/AlisaChachihina/Programmnaya_inzheneriya/assets/55950179/39c82b16-33fe-4de0-b4f0-a42b2b10c10b)

## Выводы
Создали собственный класс Ошибки, наследуемый от общего класса Exception, и умеющий выводить сообщение ошибки в зависимости от параметра. Далее считывается строку с консоли и если длина этой строки больше 10, то генерируем нашу ошибку с сообщением, что символов больше 10. Если символов меньше 5, то генерируем нашу ошибку с сообщением, что символов меньше 5.
